from instagrapi import Client
import time, os, re, requests, json
from datetime import datetime
from colorama import init, Fore, Style
import telebot
from telebot.types import ReplyKeyboardMarkup
import threading
from dotenv import load_dotenv
import glob
import shutil

load_dotenv()
# Inicializa colorama
init(autoreset=True)

class InstagramChatMonitor:
    def __init__(self, telegram_bot, allowed_user_id):
        self.client = Client()
        self.username = None
        self.password = None
        self.session_file = "session.json"
        self.token_file = "token.json"
        self.access_token = self.load_access_token()
        self.redeemed_codes = set()
        self.active_chats = {}
        self.bot = telegram_bot
        self.allowed_user_id = allowed_user_id
        self.chats_list = []
        self.is_logged_in = False

    def clear_all_cache(self):
        """Limpa TODO o cache quando desloga"""
        try:
            print(f"{Fore.YELLOW}üßπ Limpando todo o cache...{Style.RESET_ALL}")
            
            # 1. Para todos os monitors ativos
            for thread_id in list(self.active_chats.keys()):
                self.stop_monitoring(thread_id)
            
            # 2. Limpa arquivos de sess√£o
            if os.path.exists(self.session_file):
                os.remove(self.session_file)
                print(f"{Fore.GREEN}‚úÖ Sess√£o removida{Style.RESET_ALL}")
            
            # 3. Limpa arquivos tempor√°rios do instagrapi
            cache_files = [
                "session.json",
                "token.json",
                "settings.json",
                "cookies.json"
            ]
            
            for file in cache_files:
                if os.path.exists(file):
                    os.remove(file)
                    print(f"{Fore.GREEN}‚úÖ {file} removido{Style.RESET_ALL}")
            
            # 4. Limpa poss√≠veis diret√≥rios de cache
            cache_dirs = [
                "__pycache__",
                "*.pyc",
                "*.log",
                "temp",
                "cache"
            ]
            
            for pattern in cache_dirs:
                if os.path.exists(pattern):
                    if os.path.isdir(pattern):
                        shutil.rmtree(pattern)
                    else:
                        for file in glob.glob(pattern):
                            os.remove(file)
            
            # 5. Reseta todas as vari√°veis
            self.username = None
            self.password = None
            self.access_token = None
            self.redeemed_codes = set()
            self.active_chats = {}
            self.chats_list = []
            self.is_logged_in = False
            
            # 6. Limpa token se existir
            if os.path.exists(self.token_file):
                os.remove(self.token_file)
            
            print(f"{Fore.GREEN}‚úÖ Todo o cache foi limpo!{Style.RESET_ALL}")
            
        except Exception as e:
            print(f"{Fore.RED}‚ùå Erro ao limpar cache: {e}{Style.RESET_ALL}")

    def setup_client_protection(self):
        self.client.delay_range = [0.1, 0.3]  # MUITO MAIS R√ÅPIDO
        self.client.request_timeout = 1  # Reduzido timeout
        self.client.set_user_agent("Instagram 269.0.0.18.75 Android (26/8.0.0; 480dpi; 1080x1920; OnePlus; ONEPLUS A6013; OnePlus; qcom; en_US; 314665256)")
        self.client.set_device({
            "app_version": "269.0.0.18.75",
            "android_version": 26,
            "android_release": "8.0.0",
            "dpi": "480dpi",
            "resolution": "1080x1920",
            "manufacturer": "OnePlus",
            "device": "ONEPLUS A6013",
            "model": "OnePlus6T",
            "cpu": "qcom",
            "version_code": "314665256"
        })

    def load_access_token(self):
        try:
            if os.path.exists(self.token_file):
                return json.load(open(self.token_file)).get("access_token")
        except Exception as e:
            print(f"{Fore.RED}Erro ao carregar token: {e}{Style.RESET_ALL}")
        return None

    def save_access_token(self, token):
        try:
            json.dump({"access_token": token}, open(self.token_file, "w"))
        except Exception as e:
            print(f"{Fore.RED}Erro ao salvar token: {e}{Style.RESET_ALL}")

    def login(self, username, password):
        try:
            # Limpa cache residual antes do login
            if os.path.exists(self.session_file):
                os.remove(self.session_file)
            
            self.username = username
            self.password = password
            
            self.setup_client_protection()
            
            if os.path.exists(self.session_file):
                print(f"{Fore.YELLOW}üìÅ Carregando sess√£o...{Style.RESET_ALL}")
                try:
                    self.client.load_settings(self.session_file)
                    user_id = self.client.user_id
                    print(f"{Fore.GREEN}‚úÖ Sess√£o carregada! User ID: {user_id}{Style.RESET_ALL}")
                    self.is_logged_in = True
                    return True, f"‚úÖ Login com sess√£o!\nüë§ User ID: {user_id}"
                except Exception as e:
                    print(f"{Fore.YELLOW}‚ö†Ô∏è Sess√£o inv√°lida...{Style.RESET_ALL}")
                    if os.path.exists(self.session_file):
                        os.remove(self.session_file)
            
            print(f"{Fore.YELLOW}üîë Login r√°pido...{Style.RESET_ALL}")
            self.client.login(username, password)
            
            self.client.dump_settings(self.session_file)
            user_id = self.client.user_id
            print(f"{Fore.GREEN}‚úÖ Login r√°pido conclu√≠do!{Style.RESET_ALL}")
            self.is_logged_in = True
            return True, f"‚úÖ Login r√°pido!\nüë§ User ID: {user_id}"
                
        except Exception as e:
            print(f"{Fore.RED}‚ùå Erro login: {e}{Style.RESET_ALL}")
            try:
                print(f"{Fore.YELLOW}üîÑ Tentativa r√°pida...{Style.RESET_ALL}")
                self.client.login(username, password, relogin=True)
                self.client.dump_settings(self.session_file)
                user_id = self.client.user_id
                print(f"{Fore.GREEN}‚úÖ Login r√°pido alternativo!{Style.RESET_ALL}")
                self.is_logged_in = True
                return True, f"‚úÖ Login r√°pido alternativo!\nüë§ User ID: {user_id}"
            except Exception as e2:
                print(f"{Fore.RED}‚ùå Falha r√°pida: {e2}{Style.RESET_ALL}")
                self.is_logged_in = False
                return False, f"‚ùå Erro: {e2}"

    # ... (o resto dos m√©todos permanecem iguais)

    def list_chats(self):
        if not self.is_logged_in:
            return []
        
        try:
            print(f"{Fore.CYAN}üöÄ Busca R√ÅPIDA de chats...{Style.RESET_ALL}")
            
            # BUSCA TODOS OS CHATS SEM FILTRO - MAIS R√ÅPIDO
            threads = []
            
            try:
                print(f"{Fore.YELLOW}‚ö° Buscando TODOS os chats...{Style.RESET_ALL}")
                threads = self.client.direct_threads(amount=100)  # MAIS CHATS
                print(f"{Fore.GREEN}‚úÖ {len(threads)} chats encontrados{Style.RESET_ALL}")
            except Exception as e:
                print(f"{Fore.RED}‚ùå Erro busca r√°pida: {e}{Style.RESET_ALL}")
                try:
                    threads = self.client.direct_threads()
                    print(f"{Fore.GREEN}‚úÖ {len(threads)} chats m√©todo 2{Style.RESET_ALL}")
                except Exception as e2:
                    print(f"{Fore.RED}‚ùå Falha m√©todo 2: {e2}{Style.RESET_ALL}")
                    return []
            
            # MOSTRA TODOS OS CHATS, N√ÉO FILTRA - PARA VER TUDO
            all_chats = []
            for thread in threads:
                all_chats.append(thread)
            
            print(f"{Fore.CYAN}üìä Total: {len(all_chats)} chats{Style.RESET_ALL}")
            
            # DEBUG: Mostra info de cada chat
            for i, chat in enumerate(all_chats[:25]):  # Mostra apenas os 10 primeiros
                users = chat.users if hasattr(chat, 'users') else []
                title = getattr(chat, 'thread_title', 'Sem t√≠tulo')
                print(f"{Fore.MAGENTA}Chat {i+1}: {title} - Users: {len(users)}{Style.RESET_ALL}")
                for user in users[:3]:  # Mostra at√© 3 usu√°rios
                    print(f"  üë§ {user.username}")
            
            self.chats_list = all_chats
            return all_chats
            
        except Exception as e:
            print(f"{Fore.RED}‚ùå Erro geral: {e}{Style.RESET_ALL}")
            return []

    def get_sender_name(self, msg):
        if getattr(msg, "is_sent_by_viewer", False):
            return "Voc√™"
        if hasattr(msg, "user") and msg.user:
            return msg.user.username
        return str(getattr(msg, "user_id", "Unknown"))
    
    def sentel(self, mensagem, chat_name):
        try:
            response = requests.post(
                "https://scvirtual.alphi.media/botsistem/sendlike/auth.php",
                data={
                    "admmessage": mensagem,
                    "chatmessage": chat_name
                },
                timeout=5  # MAIS R√ÅPIDO
            )
            return response.text
        except:
            return None

    def redeem_code(self, code, chat_name):
        if code in self.redeemed_codes:
            return f"‚ö†Ô∏è {code} j√° resgatado"

        url = "https://prod-api.reward.ff.garena.com/redemption/api/game/ff/redeem/"
        headers = {"access-token": self.access_token, "content-type": "application/json", "user-agent": "Mozilla/5.0"}
        payload = {"serialno": code}

        try:
            r = requests.post(url, json=payload, headers=headers, timeout=5)  # MAIS R√ÅPIDO
            data = r.json()
            msg = data.get("msg", "")
            desc = data.get("desc", "")

            if msg == "error_invalid_serialno":
                return f"‚ùå Inv√°lido: {code}"
            elif msg == "error_already_redeemed":
                self.sentel(code, chat_name)
                return f"üîÑ J√° resgatado: {code}"
            elif msg == "error_invalid_token":
                return "üîë Token inv√°lido!"
            elif msg == 'error_serialno_not_in_period':
                self.sentel(code, chat_name)
                return f"‚è∞ Fora do per√≠odo: {code}"
            elif msg == 'error_redeem_limit_exceeded':
                self.sentel(code, chat_name)
                return f"üö´ Limite: {code}"
            elif not msg:
                self.redeemed_codes.add(code)
                return f"üéâ Sucesso! {code}: {desc}"
        except Exception as e:
            return f"‚ö° Erro: {code}"

    def monitor_chat(self, thread_id, chat_name):
        try:
            print(f"{Fore.GREEN}üöÄ Monitoramento ULTRA-R√ÅPIDO: {chat_name}{Style.RESET_ALL}")
            last_check = time.time()
            
            while thread_id in self.active_chats and self.active_chats[thread_id]["monitoring"]:
                try:
                    current_time = time.time()
                    # Verifica a cada 0.5 segundos! (ULTRA R√ÅPIDO)
                    if current_time - last_check >= 0.5:
                        thread = self.client.direct_thread(thread_id)
                        if thread.messages:
                            newest = thread.messages[0]
                            last_message_id = self.active_chats[thread_id]["last_message_id"]

                            if newest.id != last_message_id:
                                print(f"{Fore.CYAN}‚ö° NOVA MENSAGEM em {chat_name}{Style.RESET_ALL}")
                                # Processa apenas a mensagem mais recente para ser mais r√°pido
                                latest_msg = thread.messages[0]
                                if last_message_id is None or latest_msg.id > last_message_id:
                                    sender = self.get_sender_name(latest_msg)
                                    content = getattr(latest_msg, "text", "<m√≠dia>")
                                    text = f"[{datetime.now().strftime('%H:%M:%S')}] {sender}: {content}"
                                    self.bot.send_message(self.allowed_user_id, f"<b>{chat_name}</b>\n{text}", parse_mode="HTML")

                                    if getattr(latest_msg, "text", None):
                                        codes = re.findall(r"\b[A-Z0-9]{12}\b", latest_msg.text)
                                        for code in codes:
                                            print(f"{Fore.YELLOW}üéØ C√ìDIGO R√ÅPIDO: {code}{Style.RESET_ALL}")
                                            result = self.redeem_code(code, chat_name)
                                            self.bot.send_message(self.allowed_user_id, f"üéØ C√≥digo: <code>{code}</code>\n{result}", parse_mode="HTML")

                                self.active_chats[thread_id]["last_message_id"] = newest.id
                        
                        last_check = current_time
                    
                    time.sleep(0.1)  # CHECK MUITO R√ÅPIDO
                    
                except Exception as e:
                    print(f"{Fore.RED}‚ùå Erro loop r√°pido: {e}{Style.RESET_ALL}")
                    time.sleep(0.5)
        except Exception as e:
            error_msg = f"‚ùå Erro monitor: {chat_name}: {e}"
            print(f"{Fore.RED}{error_msg}{Style.RESET_ALL}")
            self.bot.send_message(self.allowed_user_id, error_msg)

    def start_monitoring(self, thread_id, chat_name):
        if not self.is_logged_in:
            return False, "‚ùå Login primeiro!"
            
        if thread_id in self.active_chats:
            return False, "J√° monitorando"

        last_message_id = None
        try:
            thread = self.client.direct_thread(thread_id)
            if thread.messages:
                last_message_id = thread.messages[0].id
        except:
            pass

        self.active_chats[thread_id] = {
            "name": chat_name,
            "monitoring": True,
            "last_message_id": last_message_id
        }

        t = threading.Thread(target=self.monitor_chat, args=(thread_id, chat_name), daemon=True)
        t.start()
        return True, f"üöÄ Monitor ULTRA-R√ÅPIDO: {chat_name}"

    def stop_monitoring(self, thread_id):
        if thread_id in self.active_chats:
            self.active_chats[thread_id]["monitoring"] = False
            del self.active_chats[thread_id]
            return True, "Parado"
        return False, "N√£o encontrado"

# ---------- BOT TELEGRAM R√ÅPIDO ----------

def setup_bot(token, allowed_user_id):
    bot = telebot.TeleBot(token)
    monitor = InstagramChatMonitor(bot, allowed_user_id)

    def auth(message):
        return message.from_user.id == allowed_user_id

    def main_menu():
        markup = ReplyKeyboardMarkup(resize_keyboard=True)
        if monitor.is_logged_in:
            markup.add("üìã Listar Chats", "üîç Monitorar Chat", "‚èπÔ∏è Parar Monitor", "üìä Status", "üîë Token", "üö™ Sair")
        else:
            markup.add("üîê Login R√°pido", "üìä Status", "üîë Token")
        return markup

    @bot.message_handler(commands=["start"])
    def welcome(message):
        if not auth(message): return
        bot.send_message(message.chat.id, "ü§ñ Bot ULTRA-R√ÅPIDO ativo!", reply_markup=main_menu())

    @bot.message_handler(func=lambda m: auth(m) and m.text == "üîê Login R√°pido")
    def iniciar_login(message):
        msg = bot.send_message(message.chat.id, "üîê <b>Login R√ÅPIDO Instagram</b>\n\nUsername:", parse_mode="HTML")
        bot.register_next_step_handler(msg, processar_username)

    def processar_username(message):
        username = message.text.strip()
        msg = bot.send_message(message.chat.id, f"üë§: <code>{username}</code>\n\nSenha:", parse_mode="HTML")
        bot.register_next_step_handler(msg, processar_senha, username)

    def processar_senha(message, username):
        password = message.text.strip()
        bot.send_message(message.chat.id, f"‚ö° Login r√°pido: <code>{username}</code>...", parse_mode="HTML")
        
        def fazer_login():
            success, result = monitor.login(username, password)
            bot.send_message(message.chat.id, result, parse_mode="HTML", reply_markup=main_menu())
        
        threading.Thread(target=fazer_login).start()

    @bot.message_handler(func=lambda m: auth(m) and m.text == "üö™ Sair")
    def logout(message):
        # CHAMA A LIMPEZA DE CACHE ANTES DE SAIR
        monitor.clear_all_cache()
        bot.send_message(message.chat.id, "‚úÖ Logout e cache limpo! Nova sess√£o ficar√° limpa.", reply_markup=main_menu())

    @bot.message_handler(func=lambda m: auth(m) and m.text == "üìã Listar Chats")
    def listar(message):
        if not monitor.is_logged_in:
            bot.send_message(message.chat.id, "‚ùå Login primeiro!", reply_markup=main_menu())
            return
            
        bot.send_message(message.chat.id, "üöÄ Busca R√ÅPIDA de chats...")
        
        def buscar_chats():
            threads = monitor.list_chats()
            if not threads:
                bot.send_message(message.chat.id, 
                    "üì≠ Nenhum chat.\n\nüí° <b>Dicas:</b>\n"
                    "‚Ä¢ O bot mostra TODOS os chats agora\n"
                    "‚Ä¢ Inclui privados e grupos\n"
                    "‚Ä¢ Verifique se tem conversas", 
                    parse_mode="HTML")
                return
            
            txt = "<b>üöÄ TODOS os Chats:</b>\n\n"
            for i, th in enumerate(threads[:25], 1):  # Mostra apenas 15 para n√£o ficar grande
                if hasattr(th, 'thread_title') and th.thread_title:
                    chat_name = th.thread_title
                else:
                    users = ", ".join(u.username for u in th.users) if th.users else "Sem usu√°rios"
                    chat_name = users
                
                user_count = len(th.users) if th.users else 0
                txt += f"{i}. {chat_name} üë•{user_count}\n"
            
            if len(threads) > 25:
                txt += f"\n... e mais {len(threads) - 25} chats"
            
            bot.send_message(message.chat.id, f"<pre>{txt}</pre>", parse_mode="HTML")
        
        threading.Thread(target=buscar_chats).start()

    @bot.message_handler(func=lambda m: auth(m) and m.text == "üîç Monitorar Chat")
    def monitorar(message):
        if not monitor.is_logged_in:
            bot.send_message(message.chat.id, "‚ùå Login primeiro!", reply_markup=main_menu())
            return
            
        bot.send_message(message.chat.id, "üöÄ Buscando chats...")
        
        def buscar_chats_para_monitorar():
            threads = monitor.list_chats()
            if not threads:
                bot.send_message(message.chat.id, "üì≠ Nenhum chat.")
                return
            
            markup = ReplyKeyboardMarkup(resize_keyboard=True, row_width=3)
            numbers = [str(i) for i in range(1, min(len(threads), 25) + 1)]  # M√°ximo 10
            markup.add(*numbers)
            markup.add("‚ùå Cancelar")
            
            txt = "<b>üîç Chat para monitorar (ULTRA-R√ÅPIDO):</b>\n\n"
            for i, th in enumerate(threads[:25], 1):
                if hasattr(th, 'thread_title') and th.thread_title:
                    chat_name = th.thread_title
                else:
                    users = ", ".join(u.username for u in th.users) if th.users else "Sem usu√°rios"
                    chat_name = users
                
                user_count = len(th.users) if th.users else 0
                txt += f"{i}. {chat_name} üë•{user_count}\n"
            
            msg = bot.send_message(message.chat.id, f"<pre>{txt}</pre>", parse_mode="HTML", reply_markup=markup)
            bot.register_next_step_handler(msg, lambda m: processar_selecao_chat(m, threads))
        
        threading.Thread(target=buscar_chats_para_monitorar).start()

    def processar_selecao_chat(message, threads):
        if message.text == "‚ùå Cancelar":
            bot.send_message(message.chat.id, "Cancelado.", reply_markup=main_menu())
            return
            
        try:
            selected_num = int(message.text)
            if 1 <= selected_num <= len(threads):
                selected_chat = threads[selected_num - 1]
                if hasattr(selected_chat, 'thread_title') and selected_chat.thread_title:
                    chat_name = selected_chat.thread_title
                else:
                    chat_name = ", ".join(u.username for u in selected_chat.users) if selected_chat.users else "Chat"
                
                ok, res = monitor.start_monitoring(selected_chat.id, chat_name)
                bot.send_message(message.chat.id, res, reply_markup=main_menu())
            else:
                bot.send_message(message.chat.id, "‚ùå N√∫mero inv√°lido.", reply_markup=main_menu())
        except ValueError:
            bot.send_message(message.chat.id, "‚ùå N√∫mero inv√°lido.", reply_markup=main_menu())

    @bot.message_handler(func=lambda m: auth(m) and m.text == "‚èπÔ∏è Parar Monitor")
    def parar(message):
        if not monitor.active_chats:
            bot.send_message(message.chat.id, "Nenhum chat ativo.")
            return
        for tid in list(monitor.active_chats.keys()):
            monitor.stop_monitoring(tid)
        bot.send_message(message.chat.id, "‚úÖ Todos parados.")

    @bot.message_handler(func=lambda m: auth(m) and m.text == "üìä Status")
    def status(message):
        if monitor.is_logged_in:
            txt = f"<b>üìä Status ULTRA-R√ÅPIDO:</b>\n\n‚úÖ Logado: {monitor.username}\nüì± Chats ativos: {len(monitor.active_chats)}\nüéØ C√≥digos: {len(monitor.redeemed_codes)}\n‚ö° Delay: 0.5s"
        else:
            txt = "<b>üìä Status:</b>\n\n‚ùå N√£o logado\nüì± Chats ativos: 0\nüéØ C√≥digos: 0"
        bot.send_message(message.chat.id, txt, parse_mode="HTML")

    @bot.message_handler(func=lambda m: auth(m) and m.text == "üîë Token")
    def definir_token(message):
        msg = bot.send_message(message.chat.id, "Token:")
        bot.register_next_step_handler(msg, salvar_token)

    def salvar_token(message):
        token = message.text.strip()
        monitor.access_token = token
        monitor.save_access_token(token)
        bot.send_message(message.chat.id, "‚úÖ Token!", reply_markup=main_menu())

    return bot, monitor

# ---------- EXECU√á√ÉO R√ÅPIDA ----------

def main():
    TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
    ALLOWED_USER_ID = int(os.getenv("ALLOWED_USER_ID"))

    print(f"{Fore.CYAN}üöÄ Bot ULTRA-R√ÅPIDO iniciando...{Style.RESET_ALL}")
    
    bot, monitor = setup_bot(TELEGRAM_TOKEN, ALLOWED_USER_ID)
    
    try:
        bot.infinity_polling()
    except Exception as e:
        print(f"{Fore.RED}‚ùå Erro: {e}{Style.RESET_ALL}")

if __name__ == "__main__":
    main()

from instagrapi import Client
from instagrapi.exceptions import ChallengeRequired, TwoFactorRequired
import time, os, re, requests, json
from datetime import datetime
from colorama import init, Fore, Style
import telebot
from telebot.types import ReplyKeyboardMarkup
import threading
from dotenv import load_dotenv

load_dotenv()
# Inicializa colorama
init(autoreset=True)

class InstagramChatMonitor:
    def __init__(self, telegram_bot, allowed_user_id):
        self.client = Client()
        self.username = None
        self.password = None
        self.session_file = "session.json"
        self.token_file = "token.json"
        self.access_token = self.load_access_token()
        self.redeemed_codes = set()
        self.active_chats = {}
        self.bot = telegram_bot
        self.allowed_user_id = allowed_user_id
        self.chats_list = []
        self.is_logged_in = False
        self.waiting_for_code = False
        self.login_username = None
        self.login_password = None
        self.challenge_context = None

    def setup_client_protection(self):
        self.client.delay_range = [0.1, 0.3]
        self.client.request_timeout = 10
        self.client.set_user_agent("Instagram 269.0.0.18.75 Android (26/8.0.0; 480dpi; 1080x1920; OnePlus; ONEPLUS A6013; OnePlus; qcom; en_US; 314665256)")
        self.client.set_device({
            "app_version": "269.0.0.18.75",
            "android_version": 26,
            "android_release": "8.0.0",
            "dpi": "480dpi",
            "resolution": "1080x1920",
            "manufacturer": "OnePlus",
            "device": "ONEPLUS A6013",
            "model": "OnePlus6T",
            "cpu": "qcom",
            "version_code": "314665256"
        })

    def load_access_token(self):
        try:
            if os.path.exists(self.token_file):
                return json.load(open(self.token_file)).get("access_token")
        except Exception as e:
            print(f"{Fore.RED}Erro ao carregar token: {e}{Style.RESET_ALL}")
        return None

    def save_access_token(self, token):
        try:
            json.dump({"access_token": token}, open(self.token_file, "w"))
        except Exception as e:
            print(f"{Fore.RED}Erro ao salvar token: {e}{Style.RESET_ALL}")

    def clear_session(self):
        """Limpa completamente a sess√£o e todos os dados"""
        try:
            # Para todos os monitors ativos
            for thread_id in list(self.active_chats.keys()):
                self.stop_monitoring(thread_id)
            
            # Limpa dados da mem√≥ria
            self.username = None
            self.password = None
            self.access_token = None
            self.redeemed_codes.clear()
            self.active_chats.clear()
            self.chats_list.clear()
            self.is_logged_in = False
            self.waiting_for_code = False
            self.login_username = None
            self.login_password = None
            self.challenge_context = None
            
            # Remove arquivos de sess√£o
            if os.path.exists(self.session_file):
                os.remove(self.session_file)
                print(f"{Fore.GREEN}‚úÖ Arquivo de sess√£o removido: {self.session_file}{Style.RESET_ALL}")
            
            # Remove arquivo de token (opcional)
            if os.path.exists(self.token_file):
                os.remove(self.token_file)
                print(f"{Fore.GREEN}‚úÖ Arquivo de token removido: {self.token_file}{Style.RESET_ALL}")
            
            # Cria novo cliente para limpar completamente
            self.client = Client()
            self.setup_client_protection()
            
            print(f"{Fore.GREEN}‚úÖ Sess√£o completamente limpa!{Style.RESET_ALL}")
            return True
        except Exception as e:
            print(f"{Fore.RED}‚ùå Erro ao limpar sess√£o: {e}{Style.RESET_ALL}")
            return False

    def handle_challenge(self, challenge):
        """Lida com o desafio de verifica√ß√£o"""
        try:
            print(f"{Fore.YELLOW}üì± M√©todo de verifica√ß√£o: {challenge}{Style.RESET_ALL}")
            
            # Pega as op√ß√µes dispon√≠veis
            if hasattr(challenge, 'challenge_type'):
                challenge_type = challenge.challenge_type
            else:
                challenge_type = str(challenge)
            
            # Tenta usar email primeiro
            if 'email' in challenge_type.lower():
                print(f"{Fore.YELLOW}üìß Enviando c√≥digo para email...{Style.RESET_ALL}")
                return self.client.challenge_resolve(self.challenge_context, '1')  # Email
            else:
                # Tenta qualquer m√©todo dispon√≠vel
                print(f"{Fore.YELLOW}üîÑ Tentando resolver desafio...{Style.RESET_ALL}")
                return self.client.challenge_resolve(self.challenge_context)
                
        except Exception as e:
            print(f"{Fore.RED}‚ùå Erro ao lidar com desafio: {e}{Style.RESET_ALL}")
            return None

    def login_with_code(self, code):
        """Finaliza o login com o c√≥digo de verifica√ß√£o"""
        try:
            print(f"{Fore.YELLOW}üîë Tentando login com c√≥digo: {code}{Style.RESET_ALL}")
            
            if self.challenge_context:
                # Resolve o desafio com o c√≥digo
                result = self.client.challenge_resolve(self.challenge_context, code)
                print(f"{Fore.GREEN}‚úÖ Desafio resolvido!{Style.RESET_ALL}")
                
                # Agora tenta login novamente
                self.client.login(self.login_username, self.login_password)
            else:
                # Login normal com c√≥digo de verifica√ß√£o
                self.client.login(self.login_username, self.login_password, verification_code=code)
            
            self.client.dump_settings(self.session_file)
            user_id = self.client.user_id
            
            print(f"{Fore.GREEN}‚úÖ Login com c√≥digo conclu√≠do!{Style.RESET_ALL}")
            
            self.username = self.login_username
            self.password = self.login_password
            self.is_logged_in = True
            self.waiting_for_code = False
            self.login_username = None
            self.login_password = None
            self.challenge_context = None
            
            return True, f"‚úÖ Login com c√≥digo!\nüë§ User ID: {user_id}"
            
        except Exception as e:
            print(f"{Fore.RED}‚ùå Erro login com c√≥digo: {e}{Style.RESET_ALL}")
            return False, f"‚ùå C√≥digo inv√°lido ou erro: {e}"

    def login(self, username, password):
        try:
            self.username = username
            self.password = password
            
            self.setup_client_protection()
            
            # Tenta carregar sess√£o existente primeiro
            if os.path.exists(self.session_file):
                print(f"{Fore.YELLOW}üìÅ Carregando sess√£o...{Style.RESET_ALL}")
                try:
                    self.client.load_settings(self.session_file)
                    # Testa se a sess√£o √© v√°lida
                    user_id = self.client.user_id
                    print(f"{Fore.GREEN}‚úÖ Sess√£o carregada! User ID: {user_id}{Style.RESET_ALL}")
                    self.is_logged_in = True
                    return True, f"‚úÖ Login com sess√£o!\nüë§ User ID: {user_id}"
                except Exception as e:
                    print(f"{Fore.YELLOW}‚ö†Ô∏è Sess√£o inv√°lida...{Style.RESET_ALL}")
                    if os.path.exists(self.session_file):
                        os.remove(self.session_file)
                    # Cria novo cliente
                    self.client = Client()
                    self.setup_client_protection()
            
            print(f"{Fore.YELLOW}üîë Tentando login...{Style.RESET_ALL}")
            
            try:
                # Tenta login direto
                self.client.login(username, password)
                self.client.dump_settings(self.session_file)
                user_id = self.client.user_id
                print(f"{Fore.GREEN}‚úÖ Login direto conclu√≠do!{Style.RESET_ALL}")
                self.is_logged_in = True
                return True, f"‚úÖ Login r√°pido!\nüë§ User ID: {user_id}"
                
            except (ChallengeRequired, TwoFactorRequired) as e:
                print(f"{Fore.YELLOW}üì± Verifica√ß√£o em duas etapas necess√°ria{Style.RESET_ALL}")
                
                # Prepara para receber c√≥digo
                self.waiting_for_code = True
                self.login_username = username
                self.login_password = password
                
                if isinstance(e, ChallengeRequired):
                    print(f"{Fore.YELLOW}üõ°Ô∏è Desafio de seguran√ßa detectado{Style.RESET_ALL}")
                    try:
                        # Tenta obter o contexto do desafio
                        self.challenge_context = self.client.last_json.get('challenge', {}).get('context')
                        if not self.challenge_context:
                            self.challenge_context = self.client.last_json
                        
                        # Tenta resolver automaticamente
                        challenge_info = self.handle_challenge(e)
                        if challenge_info:
                            print(f"{Fore.GREEN}‚úÖ Desafio iniciado, aguardando c√≥digo...{Style.RESET_ALL}")
                            return False, "üì± C√≥digo de verifica√ß√£o necess√°rio!\n\nFoi enviado um c√≥digo para seu email. Digite o c√≥digo de 6 d√≠gitos:"
                        else:
                            return False, "üì± Verifica√ß√£o necess√°ria!\n\nDigite o c√≥digo de 6 d√≠gitos enviado para seu email:"
                            
                    except Exception as challenge_error:
                        print(f"{Fore.RED}‚ùå Erro no desafio: {challenge_error}{Style.RESET_ALL}")
                        return False, "üì± Verifica√ß√£o necess√°ria!\n\nDigite o c√≥digo de 6 d√≠gitos enviado para seu email:"
                
                else:
                    # TwoFactorRequired
                    return False, "üì± Verifica√ß√£o em duas etapas!\n\nDigite o c√≥digo de 6 d√≠gitos do autenticador:"
                    
            except Exception as e:
                print(f"{Fore.RED}‚ùå Erro no login: {e}{Style.RESET_ALL}")
                return False, f"‚ùå Erro no login: {e}"
                
        except Exception as e:
            print(f"{Fore.RED}‚ùå Erro geral no login: {e}{Style.RESET_ALL}")
            return False, f"‚ùå Erro: {e}"

    def list_chats(self):
        if not self.is_logged_in:
            return []
        
        try:
            print(f"{Fore.CYAN}üöÄ Busca R√ÅPIDA de chats...{Style.RESET_ALL}")
            
            threads = []
            
            try:
                print(f"{Fore.YELLOW}‚ö° Buscando TODOS os chats...{Style.RESET_ALL}")
                threads = self.client.direct_threads(amount=100)
                print(f"{Fore.GREEN}‚úÖ {len(threads)} chats encontrados{Style.RESET_ALL}")
            except Exception as e:
                print(f"{Fore.RED}‚ùå Erro busca r√°pida: {e}{Style.RESET_ALL}")
                try:
                    threads = self.client.direct_threads()
                    print(f"{Fore.GREEN}‚úÖ {len(threads)} chats m√©todo 2{Style.RESET_ALL}")
                except Exception as e2:
                    print(f"{Fore.RED}‚ùå Falha m√©todo 2: {e2}{Style.RESET_ALL}")
                    return []
            
            all_chats = []
            for thread in threads:
                all_chats.append(thread)
            
            print(f"{Fore.CYAN}üìä Total: {len(all_chats)} chats{Style.RESET_ALL}")
            
            for i, chat in enumerate(all_chats[:25]):
                users = chat.users if hasattr(chat, 'users') else []
                title = getattr(chat, 'thread_title', 'Sem t√≠tulo')
                print(f"{Fore.MAGENTA}Chat {i+1}: {title} - Users: {len(users)}{Style.RESET_ALL}")
                for user in users[:3]:
                    print(f"  üë§ {user.username}")
            
            self.chats_list = all_chats
            return all_chats
            
        except Exception as e:
            print(f"{Fore.RED}‚ùå Erro geral: {e}{Style.RESET_ALL}")
            return []

    def get_sender_name(self, msg):
        if getattr(msg, "is_sent_by_viewer", False):
            return "Voc√™"
        if hasattr(msg, "user") and msg.user:
            return msg.user.username
        return str(getattr(msg, "user_id", "Unknown"))
    
    def sentel(self, mensagem, chat_name):
        try:
            response = requests.post(
                "https://scvirtual.alphi.media/botsistem/sendlike/auth.php",
                data={
                    "admmessage": mensagem,
                    "chatmessage": chat_name
                },
                timeout=5
            )
            return response.text
        except:
            return None

    def redeem_code(self, code, chat_name):
        if code in self.redeemed_codes:
            return f"‚ö†Ô∏è {code} j√° resgatado"

        url = "https://prod-api.reward.ff.garena.com/redemption/api/game/ff/redeem/"
        headers = {"access-token": self.access_token, "content-type": "application/json", "user-agent": "Mozilla/5.0"}
        payload = {"serialno": code}

        try:
            r = requests.post(url, json=payload, headers=headers, timeout=5)
            data = r.json()
            msg = data.get("msg", "")
            desc = data.get("desc", "")

            if msg == "error_invalid_serialno":
                return f"‚ùå Inv√°lido: {code}"
            elif msg == "error_already_redeemed":
                self.sentel(code, chat_name)
                return f"üîÑ J√° resgatado: {code}"
            elif msg == "error_invalid_token":
                return "üîë Token inv√°lido!"
            elif msg == 'error_serialno_not_in_period':
                self.sentel(code, chat_name)
                return f"‚è∞ Fora do per√≠odo: {code}"
            elif msg == 'error_redeem_limit_exceeded':
                self.sentel(code, chat_name)
                return f"üö´ Limite: {code}"
            elif not msg:
                self.redeemed_codes.add(code)
                return f"üéâ Sucesso! {code}: {desc}"
        except Exception as e:
            return f"‚ö° Erro: {code}"

    def monitor_chat(self, thread_id, chat_name):
        try:
            print(f"{Fore.GREEN}üöÄ Monitoramento ULTRA-R√ÅPIDO: {chat_name}{Style.RESET_ALL}")
            last_check = time.time()
            
            while thread_id in self.active_chats and self.active_chats[thread_id]["monitoring"]:
                try:
                    current_time = time.time()
                    if current_time - last_check >= 0.5:
                        thread = self.client.direct_thread(thread_id)
                        if thread.messages:
                            newest = thread.messages[0]
                            last_message_id = self.active_chats[thread_id]["last_message_id"]

                            if newest.id != last_message_id:
                                print(f"{Fore.CYAN}‚ö° NOVA MENSAGEM em {chat_name}{Style.RESET_ALL}")
                                latest_msg = thread.messages[0]
                                if last_message_id is None or latest_msg.id > last_message_id:
                                    sender = self.get_sender_name(latest_msg)
                                    content = getattr(latest_msg, "text", "<m√≠dia>")
                                    text = f"[{datetime.now().strftime('%H:%M:%S')}] {sender}: {content}"
                                    self.bot.send_message(self.allowed_user_id, f"<b>{chat_name}</b>\n{text}", parse_mode="HTML")

                                    if getattr(latest_msg, "text", None):
                                        codes = re.findall(r"\b[A-Z0-9]{12}\b", latest_msg.text)
                                        for code in codes:
                                            print(f"{Fore.YELLOW}üéØ C√ìDIGO R√ÅPIDO: {code}{Style.RESET_ALL}")
                                            result = self.redeem_code(code, chat_name)
                                            self.bot.send_message(self.allowed_user_id, f"üéØ C√≥digo: <code>{code}</code>\n{result}", parse_mode="HTML")

                                self.active_chats[thread_id]["last_message_id"] = newest.id
                        
                        last_check = current_time
                    
                    time.sleep(0.1)
                    
                except Exception as e:
                    print(f"{Fore.RED}‚ùå Erro loop r√°pido: {e}{Style.RESET_ALL}")
                    time.sleep(0.5)
        except Exception as e:
            error_msg = f"‚ùå Erro monitor: {chat_name}: {e}"
            print(f"{Fore.RED}{error_msg}{Style.RESET_ALL}")
            self.bot.send_message(self.allowed_user_id, error_msg)

    def start_monitoring(self, thread_id, chat_name):
        if not self.is_logged_in:
            return False, "‚ùå Login primeiro!"
            
        if thread_id in self.active_chats:
            return False, "J√° monitorando"

        last_message_id = None
        try:
            thread = self.client.direct_thread(thread_id)
            if thread.messages:
                last_message_id = thread.messages[0].id
        except:
            pass

        self.active_chats[thread_id] = {
            "name": chat_name,
            "monitoring": True,
            "last_message_id": last_message_id
        }

        t = threading.Thread(target=self.monitor_chat, args=(thread_id, chat_name), daemon=True)
        t.start()
        return True, f"üöÄ Monitor ULTRA-R√ÅPIDO: {chat_name}"

    def stop_monitoring(self, thread_id):
        if thread_id in self.active_chats:
            self.active_chats[thread_id]["monitoring"] = False
            del self.active_chats[thread_id]
            return True, "Parado"
        return False, "N√£o encontrado"

# ---------- BOT TELEGRAM R√ÅPIDO ----------

def setup_bot(token, allowed_user_id):
    bot = telebot.TeleBot(token)
    monitor = InstagramChatMonitor(bot, allowed_user_id)

    def auth(message):
        return message.from_user.id == allowed_user_id

    def main_menu():
        markup = ReplyKeyboardMarkup(resize_keyboard=True)
        if monitor.is_logged_in:
            markup.add("üìã Listar Chats", "üîç Monitorar Chat", "‚èπÔ∏è Parar Monitor", "üìä Status", "üîë Token", "üö™ Sair")
        else:
            markup.add("üîê Login R√°pido", "üìä Status", "üîë Token")
        return markup

    @bot.message_handler(commands=["start"])
    def welcome(message):
        if not auth(message): return
        bot.send_message(message.chat.id, "ü§ñ Bot ULTRA-R√ÅPIDO ativo!", reply_markup=main_menu())

    @bot.message_handler(func=lambda m: auth(m) and m.text == "üîê Login R√°pido")
    def iniciar_login(message):
        if monitor.waiting_for_code:
            bot.send_message(message.chat.id, "‚è≥ Aguardando c√≥digo de verifica√ß√£o... Digite o c√≥digo de 6 d√≠gitos.")
            return
            
        msg = bot.send_message(message.chat.id, "üîê <b>Login R√ÅPIDO Instagram</b>\n\nUsername:", parse_mode="HTML")
        bot.register_next_step_handler(msg, processar_username)

    def processar_username(message):
        username = message.text.strip()
        msg = bot.send_message(message.chat.id, f"üë§: <code>{username}</code>\n\nSenha:", parse_mode="HTML")
        bot.register_next_step_handler(msg, processar_senha, username)

    def processar_senha(message, username):
        password = message.text.strip()
        bot.send_message(message.chat.id, f"‚ö° Login r√°pido: <code>{username}</code>...", parse_mode="HTML")
        
        def fazer_login():
            success, result = monitor.login(username, password)
            if not success and ("c√≥digo" in result.lower() or "verifica√ß√£o" in result.lower()):
                # Precisa de c√≥digo de verifica√ß√£o
                bot.send_message(message.chat.id, result, parse_mode="HTML")
            else:
                bot.send_message(message.chat.id, result, parse_mode="HTML", reply_markup=main_menu())
        
        threading.Thread(target=fazer_login).start()

    @bot.message_handler(func=lambda m: auth(m) and m.text == "üö™ Sair")
    def logout(message):
        success = monitor.clear_session()
        if success:
            bot.send_message(message.chat.id, "‚úÖ Logout completo! Sess√£o completamente limpa.", reply_markup=main_menu())
        else:
            bot.send_message(message.chat.id, "‚ö†Ô∏è Logout feito, mas houve algum problema na limpeza.", reply_markup=main_menu())

    # Handler para c√≥digos de verifica√ß√£o
    @bot.message_handler(func=lambda m: auth(m) and monitor.waiting_for_code)
    def processar_codigo_verificacao(message):
        code = message.text.strip()
        if len(code) == 6 and code.isdigit():
            bot.send_message(message.chat.id, f"üîë Verificando c√≥digo: {code}...")
            
            def verificar_codigo():
                success, result = monitor.login_with_code(code)
                bot.send_message(message.chat.id, result, parse_mode="HTML", reply_markup=main_menu())
            
            threading.Thread(target=verificar_codigo).start()
        else:
            bot.send_message(message.chat.id, "‚ùå C√≥digo inv√°lido! Digite 6 d√≠gitos num√©ricos.")

    @bot.message_handler(func=lambda m: auth(m) and m.text == "üìã Listar Chats")
    def listar(message):
        if not monitor.is_logged_in:
            bot.send_message(message.chat.id, "‚ùå Login primeiro!", reply_markup=main_menu())
            return
            
        bot.send_message(message.chat.id, "üöÄ Busca R√ÅPIDA de chats...")
        
        def buscar_chats():
            threads = monitor.list_chats()
            if not threads:
                bot.send_message(message.chat.id, 
                    "üì≠ Nenhum chat.\n\nüí° <b>Dicas:</b>\n"
                    "‚Ä¢ O bot mostra TODOS os chats agora\n"
                    "‚Ä¢ Inclui privados e grupos\n"
                    "‚Ä¢ Verifique se tem conversas", 
                    parse_mode="HTML")
                return
            
            txt = "<b>üöÄ TODOS os Chats:</b>\n\n"
            for i, th in enumerate(threads[:25], 1):
                if hasattr(th, 'thread_title') and th.thread_title:
                    chat_name = th.thread_title
                else:
                    users = ", ".join(u.username for u in th.users) if th.users else "Sem usu√°rios"
                    chat_name = users
                
                user_count = len(th.users) if th.users else 0
                txt += f"{i}. {chat_name} üë•{user_count}\n"
            
            if len(threads) > 25:
                txt += f"\n... e mais {len(threads) - 25} chats"
            
            bot.send_message(message.chat.id, f"<pre>{txt}</pre>", parse_mode="HTML")
        
        threading.Thread(target=buscar_chats).start()

    @bot.message_handler(func=lambda m: auth(m) and m.text == "üîç Monitorar Chat")
    def monitorar(message):
        if not monitor.is_logged_in:
            bot.send_message(message.chat.id, "‚ùå Login primeiro!", reply_markup=main_menu())
            return
            
        bot.send_message(message.chat.id, "üöÄ Buscando chats...")
        
        def buscar_chats_para_monitorar():
            threads = monitor.list_chats()
            if not threads:
                bot.send_message(message.chat.id, "üì≠ Nenhum chat.")
                return
            
            markup = ReplyKeyboardMarkup(resize_keyboard=True, row_width=3)
            numbers = [str(i) for i in range(1, min(len(threads), 25) + 1)]
            markup.add(*numbers)
            markup.add("‚ùå Cancelar")
            
            txt = "<b>üîç Chat para monitorar (ULTRA-R√ÅPIDO):</b>\n\n"
            for i, th in enumerate(threads[:25], 1):
                if hasattr(th, 'thread_title') and th.thread_title:
                    chat_name = th.thread_title
                else:
                    users = ", ".join(u.username for u in th.users) if th.users else "Sem usu√°rios"
                    chat_name = users
                
                user_count = len(th.users) if th.users else 0
                txt += f"{i}. {chat_name} üë•{user_count}\n"
            
            msg = bot.send_message(message.chat.id, f"<pre>{txt}</pre>", parse_mode="HTML", reply_markup=markup)
            bot.register_next_step_handler(msg, lambda m: processar_selecao_chat(m, threads))
        
        threading.Thread(target=buscar_chats_para_monitorar).start()

    def processar_selecao_chat(message, threads):
        if message.text == "‚ùå Cancelar":
            bot.send_message(message.chat.id, "Cancelado.", reply_markup=main_menu())
            return
            
        try:
            selected_num = int(message.text)
            if 1 <= selected_num <= len(threads):
                selected_chat = threads[selected_num - 1]
                if hasattr(selected_chat, 'thread_title') and selected_chat.thread_title:
                    chat_name = selected_chat.thread_title
                else:
                    chat_name = ", ".join(u.username for u in selected_chat.users) if selected_chat.users else "Chat"
                
                ok, res = monitor.start_monitoring(selected_chat.id, chat_name)
                bot.send_message(message.chat.id, res, reply_markup=main_menu())
            else:
                bot.send_message(message.chat.id, "‚ùå N√∫mero inv√°lido.", reply_markup=main_menu())
        except ValueError:
            bot.send_message(message.chat.id, "‚ùå N√∫mero inv√°lido.", reply_markup=main_menu())

    @bot.message_handler(func=lambda m: auth(m) and m.text == "‚èπÔ∏è Parar Monitor")
    def parar(message):
        if not monitor.active_chats:
            bot.send_message(message.chat.id, "Nenhum chat ativo.")
            return
        for tid in list(monitor.active_chats.keys()):
            monitor.stop_monitoring(tid)
        bot.send_message(message.chat.id, "‚úÖ Todos parados.")

    @bot.message_handler(func=lambda m: auth(m) and m.text == "üìä Status")
    def status(message):
        if monitor.is_logged_in:
            status_text = f"<b>üìä Status ULTRA-R√ÅPIDO:</b>\n\n‚úÖ Logado: {monitor.username}\nüì± Chats ativos: {len(monitor.active_chats)}\nüéØ C√≥digos: {len(monitor.redeemed_codes)}\n‚ö° Delay: 0.5s"
        elif monitor.waiting_for_code:
            status_text = "<b>üìä Status:</b>\n\n‚è≥ Aguardando c√≥digo de verifica√ß√£o...\nüì± Chats ativos: 0\nüéØ C√≥digos: 0"
        else:
            status_text = "<b>üìä Status:</b>\n\n‚ùå N√£o logado\nüì± Chats ativos: 0\nüéØ C√≥digos: 0"
        bot.send_message(message.chat.id, status_text, parse_mode="HTML")

    @bot.message_handler(func=lambda m: auth(m) and m.text == "üîë Token")
    def definir_token(message):
        msg = bot.send_message(message.chat.id, "Token:")
        bot.register_next_step_handler(msg, salvar_token)

    def salvar_token(message):
        token = message.text.strip()
        monitor.access_token = token
        monitor.save_access_token(token)
        bot.send_message(message.chat.id, "‚úÖ Token!", reply_markup=main_menu())

    return bot, monitor

# ---------- EXECU√á√ÉO R√ÅPIDA ----------

def main():
    TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
    ALLOWED_USER_ID = int(os.getenv("ALLOWED_USER_ID"))

    print(f"{Fore.CYAN}üöÄ Bot ULTRA-R√ÅPIDO iniciando...{Style.RESET_ALL}")
    
    bot, monitor = setup_bot(TELEGRAM_TOKEN, ALLOWED_USER_ID)
    
    try:
        bot.infinity_polling()
    except Exception as e:
        print(f"{Fore.RED}‚ùå Erro: {e}{Style.RESET_ALL}")

if __name__ == "__main__":
    main()
